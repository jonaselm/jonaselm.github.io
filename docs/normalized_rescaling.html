<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Normalized Projective Estimator – Research</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Research</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./background.html"> 
<span class="menu-text">Background</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./progress.html"> 
<span class="menu-text">Current Progress</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./open_questions.html"> 
<span class="menu-text">Open Questions</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#procedure" id="toc-procedure" class="nav-link active" data-scroll-target="#procedure">Procedure</a></li>
  <li><a href="#benchmarking-vs.-rotated-mle" id="toc-benchmarking-vs.-rotated-mle" class="nav-link" data-scroll-target="#benchmarking-vs.-rotated-mle">Benchmarking vs.&nbsp;Rotated MLE</a></li>
  <li><a href="#explanation" id="toc-explanation" class="nav-link" data-scroll-target="#explanation">Explanation</a></li>
  <li><a href="#error-bounds" id="toc-error-bounds" class="nav-link" data-scroll-target="#error-bounds">Error Bounds</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Normalized Projective Estimator</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="procedure" class="level3">
<h3 class="anchored" data-anchor-id="procedure">Procedure</h3>
<p>The procedure for the normalized projective estimator is as follows. Given a matrix of (stable) observations <span class="math inline">\(\mathbf X = [X_{*,1}, \dots, X_{*,d}] \in \mathbb R^{n \times d}\)</span> with each row representing a distinct realization and each of the <span class="math inline">\(d\)</span> columns a dimension of the dataset:</p>
<ol type="1">
<li>Estimate marginal parameters of each column <span class="math inline">\(X_{*,j}\)</span> <span class="math inline">\(j=1, \dots, d\)</span> via univariate stable MLE.</li>
<li>Center each margin by subtracting its location paramter estimate: <span class="math inline">\(X_{*,j}^{(c)} = X_{*,j} - \mu_j^{MLE}\)</span></li>
<li>Normalize each observation by its Euclidean norm: <span class="math inline">\(\tilde X_{i,*} = X_{i,*}^{(c)}/\|X_{i,*}^{(c)}\|\)</span>, <span class="math inline">\(i = 1, \dots, n\)</span></li>
<li>Rescale the data by the square root of the sum of the latent marginal variances (aka the the sum of the squared scale paramters in the stable parameterization scaled by <span class="math inline">\(\sqrt 2\)</span> to match conventional Gaussian parameterization). <span class="math inline">\(\tilde{\mathbf G} = \sqrt d \bar \sigma\tilde{ \mathbf  X}\)</span>, where <span class="math inline">\(\bar \sigma = \bigg(\frac{2}{d}\sum_{j=1}^d  {\gamma_j^{MLE}}^2\bigg)^{1/2}\)</span>.</li>
<li>The dispersion matrix estimate is the sample covariance matrix of <span class="math inline">\(\tilde{\mathbf G}\)</span>: <span class="math inline">\(\hat \Sigma = \frac{1}{n}\tilde{\mathbf G}^{\top}\tilde{\mathbf G}\)</span></li>
</ol>
<p>Note that this doesn’t rely on the fact that <span class="math inline">\(X\)</span> is stable, and would hold for any so-called “Gaussian scale mixture/scale mixture of normals/<a href="https://en.wikipedia.org/wiki/Normal_variance-mean_mixture">normal variance-mean mixture</a>”, including a multivariate t distribution and generalized hyperbolic distribution, as long as we can estimate marginal scale and location paramters. These might provide some interesting opportunities to compare this estimator against more common and nicely-behaved estimators with closed forms, etc.</p>
<p>In special cases (like if we can already assume <span class="math inline">\(\mu\)</span>=0, and want to estimate the correlation matrix so that <span class="math inline">\(\bar \sigma = 1\)</span>), we don’t even need to estimate the marginal distributions.</p>
</section>
<section id="benchmarking-vs.-rotated-mle" class="level3">
<h3 class="anchored" data-anchor-id="benchmarking-vs.-rotated-mle">Benchmarking vs.&nbsp;Rotated MLE</h3>
<p>I tested this estimator against prior aproaches as well as the “Rotated MLE” approach of estimating eigenvectors using the normalized sample covariance matrix and then rotating to the eigenbasis to estimate the eigenvalues along the coordinate axes via stable MLE. The parameters used were:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">2500</span>, <span class="dv">5000</span>] </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dimensions <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">75</span>, <span class="dv">150</span>, <span class="dv">250</span>, <span class="dv">300</span>] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>alphas <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">1.5</span>, <span class="fl">1.9</span>] </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Interestingly, these two approaches perform <em>extremely</em> similarly:</p>
<p><img src="images/projective_error.png" class="img-fluid"></p>
<p>Both approaches provide a huge improvement over state-of-the-art MLE. And both show convergence to the latent Gaussian sample covariance matrix:</p>
<p><img src="images/projective_error_to_gaussian.png" class="img-fluid"></p>
<p>The Normalized Projective approach does seem to edge out Rotated MLE in most cases, however. Comparing the two approaches, the eigenvectors of the two estimates will always be identical (since they’re both based on normalization), so the differences boil down to eigenvalue estimation. Stable MLE is a bit of a black box, so it’s possible that if error in scale estimates is increasing in the magnitude of the scale but very nonlinear, doing estimation along the principal axes makes these estimates more error-prone because the error increase in the largest eigenvalue estimate is more than the error reduction in the smallest. Since the projective method estimates scale along the original coordinate axes, these are arbitrary but perhaps lower error. I’m not convinced this is actually what’s going on since I’d expect this edge to disappear as <span class="math inline">\(\alpha\)</span> increases.</p>
<p>Nevertheless, this led to the idea – “Rotated Projective” – of rotating to a new basis with approximately equal scale in all coordinate directions (this should be the minimum error estimate). Since the projective approach only needs to estimate <span class="math inline">\(\text{Tr}(\Sigma)\)</span>, which is invariant under rotations, this approach should work reasonably well, even if the rotation isn’t optimal.</p>
<p>In simulation, the Rotated Projective Estimator does seem to edge out the others (at least in total error), but not by much (this advantage is so small that on the plots above, it covers the projective approach). Some of this may be because the eigenvalues of the true covariance matrices being used for simulation are uniformly distributed. Inutitively, the equi-scale rotation should do best when there’s a big difference between top and bottom eigenvalues. I’m taking a closer look at more of a spiked covariance model. It’s possible that a sufficiently spiked model will break the assumptions of the Projective approach too much (see Explanation below).</p>
<p>But this approach of rotating to an approximately equi-scale basis and doing MLE in that basis should be doable for the Rotated MLE approach as well.</p>
<p>Working on these are the next steps…</p>
</section>
<section id="explanation" class="level3">
<h3 class="anchored" data-anchor-id="explanation">Explanation</h3>
<p>Starting off, let <span class="math inline">\(X\)</span> be an <span class="math inline">\(\alpha\)</span>-stable sub-Gaussian random vector in <span class="math inline">\(\mathbb R^d\)</span> with dispersion matrix <span class="math inline">\(\Sigma \in \mathbb R^{d \times d}\)</span>. WLOG, assume <span class="math inline">\(X\)</span> is centered at the origin (if not, it can be centered first).</p>
<p>Using the subordinator representation, we can write <span class="math inline">\(X=\sqrt W G\)</span> in the usual way with <span class="math inline">\(W \in \mathbb R^+\)</span> a maximally skewed positive <span class="math inline">\(\alpha/2\)</span>-stable subordinator and <span class="math inline">\(G \sim N(0, \Sigma)\)</span> independent of W. Assume that <span class="math inline">\(\Sigma\)</span> is “well-behaved” in the sense that it is positive definite and its eigenvalues <span class="math inline">\(\lambda_i\)</span> <span class="math inline">\(i=1, \dots d\)</span> are uniformly bounded so that there exist constants <span class="math inline">\(m, M &gt;0\)</span> independent of <span class="math inline">\(d\)</span> such that <span class="math inline">\(m \leq \lambda_i \leq M\)</span> for all <span class="math inline">\(i\)</span>. (These assumptions are probably a little too restrictive – particularly the full rank aspect, but it simplifies the argument).</p>
<p>From the eigendecomposition of <span class="math inline">\(\Sigma\)</span>, we can write <span class="math inline">\(\Sigma = O\Lambda O^\top = O\Lambda^{1/2}\Lambda^{1/2} O^\top\)</span>. Call <span class="math inline">\(\Sigma^{1/2} :=O\Lambda^{1/2}\)</span>. Let <span class="math inline">\(Z \sim N(0, I_d)\)</span> so that <span class="math inline">\(G = \Sigma^{1/2}Z\)</span>.</p>
<p>Then we can write:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{X}{\|X\|} = \frac{\sqrt WG}{\|\sqrt WG\|} = \frac{\sqrt WG}{\|\sqrt W\Sigma^{1/2}Z\|} &amp;= \frac{\sqrt WG}{\sqrt W\|O\Lambda^{1/2}Z\|}\\
&amp;= \frac{G}{\|\Lambda^{1/2}Z\|}
\end{aligned}
\]</span></p>
<p>Looking at terms in the denominator:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{1}{d}\|\Lambda^{1/2}Z\|^2 &amp; = \frac{1}{d} \sum_{i=1}^d \lambda_i Z_i^2 \\
&amp;= \frac{1}{d}\sum_{i=1}^d (\lambda_i Z_i^2 - \lambda_i + \lambda_i)\\
&amp;= \frac{1}{d}\sum_{i=1}^d \lambda_i(Z_i^2 - 1)+ \frac{1}{d}\sum_{i=1}^d \lambda_i \\
&amp;\underset{d \rightarrow \infty}{\overset{\text{a.s.}}{\longrightarrow}} 0+\frac{1}{d}\sum_{i=1}^d \lambda_i \\
&amp;= \frac{1}{d}\text{Tr}(\Sigma) \\
&amp;= \bar{\sigma}^2
\end{aligned}
\]</span></p>
<p>The argument that <span class="math inline">\(\frac{1}{d}\sum_{i=1}^d \lambda_i(Z_i^2 - 1)\underset{d \rightarrow \infty}{\overset{\text{a.s.}}{\longrightarrow}} 0\)</span> follows from Kolmogorov’s Criterion for the SLLN with independent but non-identically distributed random variables, since the sufficient conditions <span class="math inline">\(Y_i:= \lambda_i(Z_i^2 - 1)\)</span>, <span class="math inline">\(\mathbb E Y=0\)</span> and <span class="math inline">\(\sum_i^\infty \text{Var}(Y_i)/i^2 = \sum_i^\infty 2\lambda_i^2/i^2 \leq \sum_i^\infty 2M^2/i^2 =2M^2\frac{\pi^2}{6}&lt;\infty\)</span> are met.</p>
<p>Here, <span class="math inline">\(\bar{\sigma}^2\)</span> is the average variance of the components of <span class="math inline">\(G\)</span>. Applying the continuous mapping theorem, we get <span class="math inline">\(\frac{1}{d}\|\Lambda^{1/2}Z\|^2 \underset{d \rightarrow \infty}{\overset{\text{a.s.}}{\longrightarrow}} \bar{\sigma}^2 \implies \frac{\|\Lambda^{1/2}Z\|}{\sqrt d}\underset{d \rightarrow \infty}{\overset{\text{a.s.}}{\longrightarrow}}\bar{\sigma}\)</span>.</p>
<p>Note for any fixed indices <span class="math inline">\(i,j\)</span>, the bivariate vector elliptical vector <span class="math inline">\((X_i, X_j)\)</span> doesn’t depend on <span class="math inline">\(d\)</span>, nor does the corresponding latent Gaussian bivariate vector <span class="math inline">\((G_i, G_j)\)</span> – (the same is true for arbitrary fixed dimension <span class="math inline">\(k\)</span>). In other words, the components are the marginal distributions, and don’t change by adding more dimensions to the vector.</p>
<p>Putting this all together, we get:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{(X_i, X_j)}{\|X\|} &amp;= \frac{(G_i, G_j)}{\|\Lambda^{1/2}Z\|} \underset{d \rightarrow \infty}{\overset{\text{a.s.}}{\longrightarrow}} \frac{(G_i, G_j)}{\sqrt d \bar \sigma} \\
\implies &amp;\sqrt d \bar \sigma \frac{(X_i, X_j)}{\|X\|} \underset{d \rightarrow \infty}{\overset{\text{a.s.}}{\longrightarrow}} (G_i, G_j)
\end{aligned}
\]</span></p>
<p>Now, consider that for the full vector <span class="math inline">\(G\)</span>, we can write: <span class="math display">\[
\mathbb E [GG^\top] =
\begin{pmatrix}
\mathbb{E}[G_1^2] &amp; \mathbb{E}[G_1G_2] &amp; \cdots &amp; \mathbb{E}[G_1G_d] \\
\mathbb{E}[G_2G_1] &amp; \mathbb{E}[G_2^2] &amp; \cdots &amp; \mathbb{E}[G_2G_d] \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\mathbb{E}[G_dG_1] &amp; \mathbb{E}[G_dG_2] &amp; \cdots &amp; \mathbb{E}[G_d^2]
\end{pmatrix}
\]</span></p>
<p>So that we can recover <span class="math inline">\(\mathbb E [GG^\top] = \Sigma\)</span> without ever looking at more than two components of <span class="math inline">\(G\)</span> at a time. While the matrix <span class="math inline">\(\Sigma\)</span> clearly grows with <span class="math inline">\(d\)</span>, each entry is independent of the ambient dimension.</p>
<p>Note that <span class="math inline">\((\frac{Z_i}{\|Z\|})^2\)</span> <span class="math inline">\(i=1, \dots, d\)</span> is uniformly integrable, since in the uncorrelated case, a uniform random variable on the sphere <span class="math inline">\(\mathbb S^{d-1}\)</span> must satisfy <span class="math inline">\(\sum_{i=1}^d (\frac{Z_i}{\|Z\|})^2=1\)</span> and by symmetry <span class="math inline">\(\mathbb E(\frac{Z_i}{\|Z\|})^2=\frac{1}{d}\)</span>. So <span class="math inline">\(\mathbb E(\sqrt d \frac{Z_i}{\|Z\|})^2=1\)</span> and doesn’t depend on d.&nbsp;Since the eigenvalues of the covariance matrix are uniformly bounded and independent of <span class="math inline">\(d\)</span>, <span class="math inline">\((\frac{\sqrt d X_i}{\|X\|})^2\overset{\text{a.s.}}{=}(\frac{\sqrt d G_i}{\|G\|})^2\)</span> are also uniformly integrable.</p>
<p>Then for any fixed <span class="math inline">\(i,j \leq d\)</span>, <span class="math inline">\((\frac{\sqrt d X_i}{\|X\|}\frac{\sqrt d X_j}{\|X\|})\)</span> is also uniformly integrable (since it’s bounded above by <span class="math inline">\(\max\{(\frac{\sqrt d X_i}{\|X\|})^2,(\frac{\sqrt d X_j}{\|X\|})^2\}\)</span>, and the following interchange of limits and expectation is warranted. : <span class="math display">\[
\lim_{d\to\infty} \mathbb{E}\!\left[d\,\bar{\sigma}^2\,\frac{X_i}{\|X\|}\frac{X_j}{\|X\|}\right] = \mathbb{E}\!\left[ \bar{\sigma}^2\,\lim_{d\to\infty}d\,\frac{X_i}{\|X\|}\frac{X_j}{\|X\|}\right] = \mathbb{E}[G_iG_j] = \Sigma_{i,j}
\]</span></p>
<p>Since this quantity doesn’t depend on <span class="math inline">\(d\)</span>, this shows that <span class="math display">\[
d\,\bar{\sigma}^2\,\mathbb{E}\!\left[\frac{X}{\|X\|}\frac{X}{\|X\|}^\top\right] \to \mathbb{E}[GG^\top] = \Sigma
\]</span></p>
<p>in the sense that every finite block converges entrywise.</p>
</section>
<section id="error-bounds" class="level3">
<h3 class="anchored" data-anchor-id="error-bounds">Error Bounds</h3>
<p>The fact that the denominator in the normalized vector simplifies to a Gaussian vector norm (almost surely) means that we should be able to apply standard quadratic form conentration bounds (e.g.&nbsp;Hanson-Wright) to determine the impact of this Gaussian approximation in finite dimensions (e.g.&nbsp;how close can we get to recovering the sample covariance matrix of the latent Gaussian vector).</p>
<p>If we’re interested in how much error this approximation adds to the process, a reasonable thing to look at might be the probability of a large distance between the estimator versus the latent Gaussian sample covariance matrix, <span class="math inline">\(\Sigma_G\)</span> (if it were observable). This simplifies to:</p>
<p>[Need to add more details, but this simplifies to a quadratic form that one can apply Hanson-Wright to (Vershynin Thm 6.2.1) to show this error has sub-Gaussian concentration for small deviations. This explains the rapid convergence to the latent Gaussian SCM in my simulations.]</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>