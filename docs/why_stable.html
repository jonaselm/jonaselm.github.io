<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Research - Why Stable?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Research</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./background.html"> 
<span class="menu-text">Background</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./progress.html"> 
<span class="menu-text">Current Progress</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./open_questions.html"> 
<span class="menu-text">Open Questions</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#why-stable" id="toc-why-stable" class="nav-link active" data-scroll-target="#why-stable">Why Stable?</a>
  <ul class="collapse">
  <li><a href="#why-arent-stable-models-more-common-in-finance" id="toc-why-arent-stable-models-more-common-in-finance" class="nav-link" data-scroll-target="#why-arent-stable-models-more-common-in-finance">Why Aren’t Stable Models More Common in Finance?</a></li>
  </ul></li>
  <li><a href="#why-sub-gaussian" id="toc-why-sub-gaussian" class="nav-link" data-scroll-target="#why-sub-gaussian">Why Sub-Gaussian</a></li>
  <li><a href="#why-infinite-variance" id="toc-why-infinite-variance" class="nav-link" data-scroll-target="#why-infinite-variance">Why Infinite Variance</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Why Stable?</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This page tries to explain the benefits of a stable model conversationally. I think a more formal, example-filled, adequately sourced version of this discussion would be useful early in my dissertation. But hopefully, this version is helpful for understanding my desire to use the stable model!</p>
</div>
</div>
<p>The question has come up – why use an alpha-stable distribution to model investment returns in the first place?</p>
<p>It’s worth noting that <strong>my goal isn’t necessarily to build an estimator that only works on stable distributions, but rather to build one that doesn’t immediately break if the distribution of the data is heavy tailed</strong>. Working with the stable distribution gives us something to anchor to for theoretical results.</p>
<p>Even when variance exists, my conjecture is that in the presence of heavy tails, a model that can accomodate infinite variance probably does better at measuring dependence in finite samples.</p>
<p>(Or to paraphrase a comment I read on the internet: in the real world, a slowly converging integral is no better than one that doesn’t converge at all.)</p>
<section id="why-stable" class="level2">
<h2 class="anchored" data-anchor-id="why-stable">Why Stable?</h2>
<p>Stable distributions generalize the normal distribution, which has typically been used commonly in finance, allowing for heavier tails – and shocks or jumps.</p>
<p>Arguably, for any stochastic additive process with countably infinite increments (e.g.&nbsp;like log-returns), if “sufficiently large” summands aren’t suitably well-behaved, we have an argument for using a stable distribution. More concretely, when the central limit theorem provides a justification for using the normal distribution throughout mathematical finance, when the variance of those increments is infinite or the tails of the increments are large enough that their sums have slow convergence to the Gaussian regime, a stable distribution makes more sense.</p>
<p>By the Generalized CLT of Gnedenko and Kolmogorov (1954), <strong>the sums of any i.i.d. random variables must be alpha-stable in distribution.</strong></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/meucci_stable.png" class="img-fluid figure-img"></p>
<figcaption>From Meucci’s “Risk and Asset Allocation”, stable distributions in the taxonomy of distributions; N denotes the normal.</figcaption>
</figure>
</div>
<p>Financial returns have been observed to be strongly non-Gaussian for nearly a century, and in the early 1960s, the stable distribution was suggested as a model for financial returns <a href="https://web.williams.edu/Mathematics/sjmiller/public_html/341Fa09/econ/Mandelbroit_VariationCertainSpeculativePrices.pdf">by Benoit Mandlebrot</a>. Around that same time, significant research was done in extending Gaussian assumptions in asset pricing models to the more realistic stable distribution by future Nobel laureate Eugene Fama. More recently, books like <a href="https://www.amazon.com/Stable-Paretian-Models-Finance-Svetlozar/dp/0471953148">Stable Paretian Models in Finance</a> have extended more contemporary financial models to being driven by stable distributions.</p>
<section id="why-arent-stable-models-more-common-in-finance" class="level3">
<h3 class="anchored" data-anchor-id="why-arent-stable-models-more-common-in-finance">Why Aren’t Stable Models More Common in Finance?</h3>
<p>Despite significant theory and justification for using stable distributions, they’re not commonly used in practice. One reason for that is that they’re less accessible to non-mathematicians than simpler Gaussian models, while also implying less explainability than more sophisticated models that only work in the rearview mirror (e.g.&nbsp;ex post, there is more noise).</p>
<p>I’d speculate that another reason has to do with timing. When Harry Markowitz introduced Modern Portfolio Theory in the 1950s, he brought the idea that variance should be used as a measure of investment risk, and presented a framework for portfolio contruction that implied Gaussian returns - the mean-variance approach pioneered by Markowitz at this time only guarantees optimality if the distribution of returns is fully parameterized by its mean and variance, which forms a complete sufficient statistic for the Gaussian. This made the normal distribution a more appealing choice during this time.</p>
<p>By the time enough computational power was available to deal with stable distributions (and, for instance, calculate their PDFs and estimate parameters using MLE), that computational power could be used instead for nonparametric/empirical approaches, and many practitioners burned by failures of the Gaussian model were turned off by parameteric approaches. In some sense, stable distributions missed the boat despite arguably being a better model than either (empirical distributions in particular are problematic because of the “unseen” tail that’s impossible to estimate for events that haven’t happened yet).</p>
<p><strong>The idea of using standard deviation to define investment volatility (and risk) has likely been one of the biggest challenges to seeing stable models get used more widely.</strong> Some have argued that infinite variance implies infinite risk, which is not correct.</p>
<p>In fact, stable distributions have well-defined scale parameters that behave just like standard deviation in the Gaussian case – as I’ll go into below, they are exactly related to standard deviation in the <span class="math inline">\(\alpha\)</span>-SG(<span class="math inline">\(\Sigma\)</span>) case.</p>
<p>These scale parameters have direct applications to portfolio optimization when simple returns are stable, and more importantly, they describe the decreasing marginal benefit to diversification that we see in the real world when returns come from heavy-tailed distributions (See Nolan, 2020, p.&nbsp;35).</p>
</section>
</section>
<section id="why-sub-gaussian" class="level2">
<h2 class="anchored" data-anchor-id="why-sub-gaussian">Why Sub-Gaussian</h2>
<p>When thinking about stable distributions as a generalization of the Gaussian, the <span class="math inline">\(\alpha\)</span>-SG(<span class="math inline">\(\Sigma\)</span>) class of stable distributions can be thought of as a minimal relaxation: they share all the dependence structure of a Gaussian, but have the ability to present heavier tails and jumps.</p>
<p>Stable distrbutions lend themselves well to portfolio construction when they model simple returns; the dispersion matrix <span class="math inline">\(\Sigma\)</span> has been shown to be a coherent risk metric that can be used to build a portfolio when an agent is averse to risk. (<a href="https://methods.stat.kit.edu/download/doc_secure1/SubGaussianDAX30-KRHF-FV.pdf">See Kring, et al., 2009</a>)</p>
<p>While more complicated dependence structures are possible with a stable distribution by lifting the symmetry assumption, I think the tradeoff lies in the ability to estimate those parameters well enough as well as the futility of trying to accomodate those dependence structures in a portfolio whose returns are an affine transformation of the underlying return vector. In other words, the juice isn’t worth the squeeze for a more complex model.</p>
</section>
<section id="why-infinite-variance" class="level2">
<h2 class="anchored" data-anchor-id="why-infinite-variance">Why Infinite Variance</h2>
<p>Infinite variance itself isn’t necessarily a desirable attribute for our model distribution. Rather, it is a side effect of having a target distribution that can accomodate realistic jumps/shocks/outliers.</p>
<p>While it’s true that with a stable distribution we have positive probability of seeing an arbitrarily large realization, the same is true of the normal distribution too!</p>
<p>So, this question is less “why infinite variance?” and more “why <em>not</em> infinite variance?”</p>
<p>Ultimately, infinite variance says more about a distribution’s speed of tail decay than it does about the likelihood of an extreme event in general. I’ll attempt to address some possible objections to infinite variance models below:</p>
<p><strong>Infinite variance does not say anything about the variability of a distribution</strong></p>
<p>While variance can be a useful metric to compare the variability of distributions, once it’s infinite, it’s no longer meaningful to compare.</p>
<p>As an example, take the Cauchy distribution below, a symmetric distribution which has infinite integer moments:</p>
<p><img src="images/cauchy.png" class="img-fluid"></p>
<p>Compare this to a <span class="math inline">\(N(10^8,1)\)</span> distribution, and taking random deviates from each, it’s clear that the Cauchy’s central tendency or typical realizations are not “higher” in any sense. It’s is simply no longer a meaningful quantity (no pun intended) because the integral fails to converge.</p>
<p>Similarly, the stable random variable <span class="math inline">\(X \sim S_{1.9}(0.01,0,0)\)</span> with 99.9985% of its probability density on [-1,1] has infinite variance. When the second moment doesn’t converge, that’s really only a commentary on the speed of tail decay relative to the expectation being integrated.</p>
<p><strong>Infinite variance models are a realistic choice for investment returns.</strong></p>
<p>Empirically, investment returns are heteroskedastic. This has led to many more complicated models to explain the behavior of prices (regime models, stochastic volatility, etc.).</p>
<p>But looking at even a very simple Lèvy flight driven by a stable distribution, the empirical rolling standard deviation is quite well modeled by stable returns:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/rolling_sd.png" class="img-fluid figure-img"></p>
<figcaption>From my Stable Bands paper (2023); Rolling 20-day standard deviation of S&amp;P 500 returns in red vs.&nbsp;the same from an infinite variance stable distribution fit to S&amp;P returns in blue.</figcaption>
</figure>
</div>
<p><strong>Finite variance does not solve the practical challenges of heavy tails</strong></p>
<p>When we allow the second moment to exist in a heavy-tailed distribution, we do regain some nice theoretical properties but, in practice, results will largely be indistinguishable from the infinite variance regime.</p>
<p>For example even if variance is finite, convergence of the integral (and by extension a sample-based estimate of it) may be so slow that finite-sample estimates are effectively stochastic. This is almost more problematic because it creates a tendency to be overconfident in higher-moment estimates.</p>
<p>With the stable model, the <span class="math inline">\(\alpha\)</span> parameter can be treated like a confidence metric for moment estimates; for instance, <span class="math inline">\(\alpha\)</span> near 2 suggests that the mean will likely be well behaved and reliably estimated in small samples.</p>
<p><strong>Infinite variance does not imply infinite or undefined variability.</strong></p>
<p>While variance may be undefined, other measures of variability, such as mean absolute deviation will exist when <span class="math inline">\(\alpha&gt;1\)</span>. Likewise, median absolute deviation will always exist. Arguably, even if variance did exist as well, one of these more robust measures of variability may be a more appropriate/interpretable quantity in a heavy-tailed application like modeling financial returns.</p>
<p>Likewise, while theoretical variance may be undefined for a stable distribution, sample variance from a realization of that stable distribution will always exist and controlling it is a common investment objective in portfolio construction.</p>
<p>In that case, it’s straightforward that the minimum stable scale portfolio will also be the portfolio with the smallest expected median realized standard deviation. Similar extensions can be made for other objectives.</p>
<p>Moreover, by appreciating the fact that target metrics may not converge in expectation, it’s possible to treat them more realistically - e.g.&nbsp;by building a portfolio that has a 90% probability of not exceeding an undesirable sample standard deviation.</p>
<p><strong>Infinite variance does not mean that tail events are more likely.</strong></p>
<p>It’s true that under some regularity conditions (e.g.&nbsp;unimodal and monotonically decreasing tails) a stable random variable will have higher variability (however you choose to measure it) than, say, a normal random variable with the same scale parameter. But that setup artificially handicaps the stable random variable.</p>
<p>With some of the variability “handled” by a lower <span class="math inline">\(\alpha\)</span>, the stable random variable fit to the same data as a Gaussian will have a lower scale parameter.</p>
<p>One way to see this is that by choosing a Gaussian with the probability of an “extreme event” p, I can choose a scale parameter for a stable random variable with arbitrary choice of <span class="math inline">\(\alpha\)</span> such that the probability of the same extreme event is less than p.</p>
<p>For this reason, infinite variance distributions are more reasonable than normal distributions for modeling exceptionally low-volatility assets that endure rare, but proportionally meaningful price shocks.</p>
<p><strong>An unbounded distribution is a reasonable choice for investment returns.</strong></p>
<p>Because this is also a characteristic of the Gaussian, this question doesn’t get addressed often.</p>
<p>There is no economic theory I’m aware of that would justify hard bounds on investment returns. Anything is possible, however vanishingly small the probability of a quadrillion-percent move. In fact, because of the fact that investment returns are heavy-tailed imposing a hard upper limit (and getting it wrong) will have drastic consequences on the interpretation of the model.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>