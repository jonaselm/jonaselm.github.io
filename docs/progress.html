<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Research - Current Progress</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Research</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./background.html"> 
<span class="menu-text">Background</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./progress.html" aria-current="page"> 
<span class="menu-text">Current Progress</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./open_questions.html"> 
<span class="menu-text">Open Questions</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#estimating-sigma" id="toc-estimating-sigma" class="nav-link active" data-scroll-target="#estimating-sigma">Estimating <span class="math inline">\(\Sigma\)</span></a>
  <ul class="collapse">
  <li><a href="#bias-of-the-flom-estimator" id="toc-bias-of-the-flom-estimator" class="nav-link" data-scroll-target="#bias-of-the-flom-estimator">Bias of the FLOM Estimator</a></li>
  <li><a href="#variance-of-the-flom-estimator" id="toc-variance-of-the-flom-estimator" class="nav-link" data-scroll-target="#variance-of-the-flom-estimator">Variance of the FLOM Estimator</a></li>
  <li><a href="#variance-of-the-correlation-estimators" id="toc-variance-of-the-correlation-estimators" class="nav-link" data-scroll-target="#variance-of-the-correlation-estimators">Variance of the Correlation Estimators</a></li>
  </ul></li>
  <li><a href="#the-subordinated-covariance-estimators" id="toc-the-subordinated-covariance-estimators" class="nav-link" data-scroll-target="#the-subordinated-covariance-estimators">The Subordinated Covariance Estimators</a></li>
  <li><a href="#subordinated-correlation-estimator" id="toc-subordinated-correlation-estimator" class="nav-link" data-scroll-target="#subordinated-correlation-estimator">Subordinated Correlation Estimator</a></li>
  <li><a href="#restricted-expectation-maximization-approach" id="toc-restricted-expectation-maximization-approach" class="nav-link" data-scroll-target="#restricted-expectation-maximization-approach">Restricted Expectation-Maximization Approach</a></li>
  <li><a href="#normalized-sample-covariance-matrix-approach-nscm" id="toc-normalized-sample-covariance-matrix-approach-nscm" class="nav-link" data-scroll-target="#normalized-sample-covariance-matrix-approach-nscm">Normalized Sample Covariance Matrix Approach (NSCM)</a></li>
  <li><a href="#empricical-copula-transform" id="toc-empricical-copula-transform" class="nav-link" data-scroll-target="#empricical-copula-transform">Empricical Copula Transform</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Current Progress</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>I’ve split the problem into two pieces: getting an “optimal” estimate of the covariance/correlation matrix underlying a stable-sub-Gaussian random vector, and adjusting for high-dimensionality. It’s a little hand-wavy, but I think this is reasonable since the RIE is a monotonically increasing function of the eigenvalues of the input. So, by the invariance of quantiles under monotone transformations, the median RIE estimate at each eigenvalue should be the same as the RIE of the median eigenvalue estimate.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Calculating FLOMs
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note: <a href="./corr_variance_derivation.html">On this page</a>, I’ve derived some preliminaries that are useful for calculating the theoretical joint moments of FLOM estimators.</p>
</div>
</div>
<section id="estimating-sigma" class="level2">
<h2 class="anchored" data-anchor-id="estimating-sigma">Estimating <span class="math inline">\(\Sigma\)</span></h2>
<p>We want to estimate the covariance matrix <span class="math inline">\(\Sigma\)</span> of the underlying Gaussian vector that defines the dependence structure of our stable random variable <span class="math inline">\(X\)</span>.</p>
<p><a href="https://hal.science/hal-00951885">Kodia and Garel</a> propose a signed symmetric covariation coefficient:</p>
<p><span class="math display">\[
\text{scov} (X_1, X_2) = \kappa_{(X_1, X_2)}\bigg | \frac{[X_1, X_2]_\alpha [X_2, X_1]_\alpha}{||X_1||_\alpha ||X_2||_\alpha} \bigg|^{1/2}
\]</span></p>
<p>Here, <span class="math inline">\([X_1, X_2]_\alpha\)</span> and <span class="math inline">\(||X_1||_\alpha\)</span> are the covariation of <span class="math inline">\(X_1\)</span> on <span class="math inline">\(X_2\)</span> and the covariation norm of <span class="math inline">\(X_1\)</span>, respectively, and <span class="math inline">\(\kappa\)</span> represents the “agreement” of the signs of the covariation terms.</p>
<p>When <span class="math inline">\(1 &lt; \alpha &lt; 2\)</span>, this can equivalently be represented using Fractional Lower Order Moments (FLOMs):</p>
<p><span class="math display">\[
r = \frac{(\mathbb E |X_1|^p)^{2/p}+(\mathbb E |X_2|^p)^{2/p}-(\mathbb E |X_1- X_2|^p)^{2/p}}{2(\mathbb E |X_1|^p\mathbb E |X_2|^p)^{1/p}}
\]</span></p>
<p>In both cases, when <span class="math inline">\(X\)</span> is a sub-Gaussian random vector with underlying Gaussian vector <span class="math inline">\(G\)</span>, these quantities coincide with the correlation coefficient between <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span>.</p>
<p>Kodia and Garel show that straightforward estimators based on these quantities are strongly consistent estimators of the Gaussian correlation matrix.</p>
<section id="bias-of-the-flom-estimator" class="level3">
<h3 class="anchored" data-anchor-id="bias-of-the-flom-estimator">Bias of the FLOM Estimator</h3>
<p>Note that FLOMs aren’t unbiased estimators of scale/dependence unless <span class="math inline">\(p=2\)</span>.</p>
<p>Proposition 1 on p.32 of <a href="https://catalyst.library.jhu.edu/permalink/01JHU_INST/t3c16/alma991014131159707861">Nikias and Shao</a> is:</p>
<p><span class="math display">\[
\mathbb E(|X|^p) = C(p,\alpha)\gamma^{p/\alpha}
\]</span></p>
<p>where <span class="math inline">\(C(p,\alpha)\)</span> is a known constant that depends only on p and the tail exponent of X and is used below, and <span class="math inline">\(\gamma\)</span> is the scale parameter of X. Note that the authors use a non-typical parameterization for <span class="math inline">\(\gamma\)</span> but this result holds in general for any distribution – <a href="./open_questions.html">rough/hand-wavy proof here</a>.</p>
<p>One nice thing is that if we’re estimating a correlation-type quantity like scov and r above, these bias terms cancel out in the numerator and denominator, and we’re left only with the scale terms.</p>
</section>
<section id="variance-of-the-flom-estimator" class="level3">
<h3 class="anchored" data-anchor-id="variance-of-the-flom-estimator">Variance of the FLOM Estimator</h3>
<p>One area that (surprisingly) has received little attention in the literature is the variance of these FLOM estimators. While the variance of <span class="math inline">\(X\)</span> may be infinite, we can estimate its scale and dependence using FLOMs with finite variance.</p>
<p>It’s known that for <span class="math inline">\(p&lt;\alpha, \mathbb E |X|^p &lt; \infty\)</span>. Therefore, the variance of <span class="math inline">\(|X|^p\)</span> exists for <span class="math inline">\(p&lt;\alpha/2\)</span>. Several papers estimate sample FLOM variance using Monte Carlo simulations, but I haven’t seen analytical representations in any papers. In this case, it’s a straightforward application of the expected value of the FLOM:</p>
<p><span class="math display">\[
\begin{aligned}
\text{Var}(\frac{1}{N}\sum_{i=1}^N |X|^p) &amp; = N^{-2} \text{Var}(\sum_{i=1}^N |X|^p) \\
&amp;= N^{-1} [\mathbb E(|X|^{2p}) - \mathbb E(|X|^p)^2] \\
&amp;= N^{-1} [C(2p,\alpha)\gamma^{2p/\alpha}-(C(p, \alpha)\gamma^{p/\alpha})^2]\\
&amp;= \frac{2^{2p+2}\gamma^{2p/\alpha}}{N \alpha \sqrt \pi}\bigg\{ \frac{\Gamma(\frac{2p+1}{2})\Gamma(-2p/\alpha)}{\Gamma(-p)} - \frac{\Gamma(\frac{p+1}{2})^2 \Gamma(-p/\alpha)^2 }{\alpha \sqrt\pi\Gamma(-p/2)^2} \bigg\}
\end{aligned}
\]</span></p>
<p>What’s interesting is that simulation results are problematically misleading when <span class="math inline">\(X\)</span> is nearly Gaussian:</p>
<p><img src="images/FLOM_simulated_vs_analytical_sd.png" class="img-fluid"></p>
<p>The chart above simulates 10,000 samples to estimate the standard error of the FLOM estimator as a function of p at various values of <span class="math inline">\(\alpha\)</span>. When p gets near the infinite variance regime, simulations will materially underestimate the variability of the estimator, especially when <span class="math inline">\(\alpha \uparrow 2\)</span>. Heuristically, this is because tails are only a little heavier than the Gaussian case, and you’re much less likely to get extreme realizations that traverse the full support of the distribution via simulation unless your sample size is massive. In these examples, the simulation approach requires tens of millions of simulations to get close to the analyical standard deviation of the estimator.</p>
<p>I think this is an incredibly interesting aside that I haven’t seen covered in the literature so far.</p>
<p>This is relevant because <a href="https://ieeexplore.ieee.org/document/8579596">some papers</a> have suggested choosing optimal p to be <span class="math inline">\(p \lesssim \alpha/2\)</span> (e.g.&nbsp;right on the boundary of finite variance).</p>
<p>The variance of the FLOM is monotonically increasing in p, and some have suggested making p as small as possible. The difficulty is that <span class="math inline">\(\lim_{p \rightarrow 0} C(p, \alpha) = \infty\)</span>. This problem doesn’t exist in the correlation estimator case.</p>
</section>
<section id="variance-of-the-correlation-estimators" class="level3">
<h3 class="anchored" data-anchor-id="variance-of-the-correlation-estimators">Variance of the Correlation Estimators</h3>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note: The correlation-type estimators are being abandoned since they perform far worse than original Median Oracle despite some nice theoretical properties.</p>
</div>
</div>
<p>When our estimator is a correlation-type estimator like scov and r above, any sample estimate is bounded on <span class="math inline">\([-1,1]\)</span> and all moments of the estimator itself are finite for any p – even <span class="math inline">\(p&gt;\alpha\)</span>!</p>
<p>Like with raw FLOMs, Monte Carlo has been used to estimate variance of these estimators in <a href="https://ieeexplore.ieee.org/document/1673451">some papers</a>, but only with relatively small simulation sizes and without comment on potential errors in the calculation of an optimal p.</p>
<p>Since we can induce finite variance on the components of these estimators, it seems reasonable to invoke the delta method to approximate their asymptotic variance using Taylor series expansions to get a better estimate of a variance-minimizing choice of p.</p>
<p>My derivation of the correlation-type estimator variance approximation <a href="./corr_variance_derivation.html">can be found here</a>.</p>
<p>Unfortunately, this variance approximation doesn’t work very nicely in practice for moderate-sized simulations:</p>
<p><img src="images/corr_simulated_vs_analytical_sd.png" class="img-fluid"></p>
<p>And worse, plugging it into the current Median Oracle algorithm in place of sample covariance results in worse estimates. I think this is happening because throwing away the magnitude information for a correlation-type estimator results in worse estimates. The good news is that an estimator based on the numerator of r should fix this problem. The bad news is that it reintroduces infinite estimator variance.</p>
</section>
</section>
<section id="the-subordinated-covariance-estimators" class="level2">
<h2 class="anchored" data-anchor-id="the-subordinated-covariance-estimators">The Subordinated Covariance Estimators</h2>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note: This estimator is also being put on ice due to infinite moments. I’m continuing to investigate more estimators of this type to see if I can get something that reverts to sample covariance as a special case when the data are Gaussian, but has better moment properties. Alternatives to estimator variance might also be helpful.</p>
</div>
</div>
<p>If we just take the rescaled numerator of r, we get the following:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;(\mathbb E |X_1|^p)^{2/p}+(\mathbb E |X_2|^p)^{2/p}-(\mathbb E |X_1- X_2|^p)^{2/p} \\
&amp;= (C(p,\alpha)\gamma_1^p)^{2/p}+(C(p,\alpha)\gamma_2^p)^{2/p}-(C(p,\alpha)\gamma_3^p)^{2/p}
\\
&amp; = C(p,\alpha)^{2/p}\bigg[\gamma_1^2 + \gamma_2^2 -\gamma_3^2 \bigg] \\
&amp;=C(p,\alpha)^{2/p}\bigg[\frac{\sigma_1^2}{2} + \frac{\sigma_2^2}{2} -\frac{\sigma_3^2}{2}  \bigg] \\
&amp;=C(p,\alpha)^{2/p}\bigg[\frac{\sigma_1^2}{2} + \frac{\sigma_2^2}{2} -(\frac{\sigma_1^2}{2} + \frac{\sigma_2^2}{2}-\frac{2\rho_{12}\sigma_1\sigma_2}{2}) \bigg] \\
&amp;= C(p,\alpha)^{2/p}\rho_{12}\sigma_1\sigma_2
\end{aligned}
\]</span></p>
<p>The subordinated covariance estimator is defined as <span class="math inline">\(\hat s\)</span> below:</p>
<p><span class="math display">\[
\begin{aligned}
\hat s &amp;= \frac{(\frac{1}{N}\sum_{i=1}^N |X_{1i}|^p)^{2/p} + (\frac{1}{N}\sum_{i=1}^N |X_{2i}|^p)^{2/p} -(\frac{1}{N}\sum_{i=1}^N |X_{1i} - X_{2i}|^p)^{2/p}}{C(p,\alpha)^{2/p}}
\end{aligned}
\]</span></p>
<p>One immediate benefit of this estimator is that, when <span class="math inline">\(p=2\)</span>, this estimator is exactly the sample covariance (which is an input into the Median Oracle estimator). This provides a very reasonable path to improving the performance of Median Oracle - when <span class="math inline">\(\alpha&lt;2\)</span>, the sample covariance is a biased estimator of the subordinated covariance, and <span class="math inline">\(p=2\)</span> may not be optimial anymore.</p>
<p>The problem, though, is that this formulation cannot have finite moments (this follows from Jensen’s inequality; we need <span class="math inline">\(p&gt;2\)</span> to be finite for finite moments, which is a contradiction.)</p>
<p>I’m continuing to explore potential estimators of this type.</p>
</section>
<section id="subordinated-correlation-estimator" class="level2">
<h2 class="anchored" data-anchor-id="subordinated-correlation-estimator">Subordinated Correlation Estimator</h2>
<p>My derivation of the <a href="https://jonaselm.github.io/corr_variance_derivation.html">FLOM covariance</a> leads to (what I believe is) a novel estimator for the correlation coefficient of the subordinated Gaussian vector.</p>
<p>Using the fact that: <span class="math display">\[
\begin{aligned}
\mathbb E(|X_1 X_2|^p) &amp;= \frac{2\Gamma(-2p/\alpha)}{\alpha\Gamma(-p)}\bigg(\frac{2^{p+1} \gamma_1^{p/} \gamma_2^{p}}{\pi}\bigg)\Gamma(\frac{p+1}{2})^2{}_2F_1(-\frac p 2, -\frac p 2, \frac 1 2, \rho^2)
\end{aligned}
\]</span></p>
<p>This requires that <span class="math inline">\(p &lt; \alpha/2\)</span>. From there, we can get the following estimator for the underlying correlation between <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
\hat \rho = \text{sign}\bigg( \frac 1 N \sum_{i=1}^N \text{sign}(X_{1i} X_{2i}) \bigg) \bigg| {_2F_{1p}}^{-1}\bigg( \frac{\alpha \pi \Gamma(-p)\sum_{i=1}^N|X_{1i} X_{2i}|^p}{N2^{p+2}(\gamma_1 \gamma_2)^p\Gamma(\frac{p+1}{2})^2}\bigg)\bigg|^{1/2}
\end{aligned}
\]</span></p>
<p>Here, I use <span class="math inline">\({_2F_{1p}}^{-1}(\cdot)\)</span> to denote the inverse of the hypergeometric function <span class="math inline">\({}_2F_1(-\frac p 2, -\frac p 2, \frac 1 2, \rho^2)\)</span>, such that <span class="math inline">\({_2F_{1p}}^{-1}({}_2F_1(-\frac p 2, -\frac p 2, \frac 1 2, \rho^2))=\rho^2\)</span>. While a bit nasty and not ideal for analyzing the behavior of this estimator, this can be implemented numerically without much trouble.</p>
<p>A quick examination of the hypergeometric function on the relevant domain shows that it’s really not cause for concern despite lacking a closed form:</p>
<p><img src="images/inverse_hyp.png" class="img-fluid"></p>
<p>It’s worth taking a second to justify taking the mean of the sign function, since <span class="math inline">\(\mathbb E X_1 X_2 \nless \infty\)</span>. Note that <span class="math inline">\(\text{sign}(XY) \in \{-1, 1\}\)</span>, so the random variable is bounded and all moments are finite. Equivalently, <span class="math inline">\(\mathbb E[\text{sign}(XY)] = P(XY &gt; 0)- P(XY &lt; 0) \in (-1,1)\)</span>, which always exists.</p>
<p>Because of our expectation definition above, this estimator will converge pointwise in probability to <span class="math inline">\(\rho\)</span> by the law of large numbers. Better yet, it will have finite variance when <span class="math inline">\(p &lt; \alpha/2\)</span>, which is required to get the subordinator to have finite expectation. This is a somewhat stronger claim for finite variance than the correlation estimator candidate offered above (which was made simply on the basis of it being bounded). So it might have better small-sample performance.</p>
<p>The benefits of this estimator are that it has finite variance and it should be extrmeley computationally cheap.</p>
<p>There are a few of problems with this estimator: First we can’t make any guarantees about convergence in expectation. Second, I don’t really expect it to perform incredibly well because of the need to estimate other parameters as inputs. Third, it doesn’t fix the issue of correlation-only estimates having worse performance in Median Oracle. The latter is fixed by recombining it with estimates of <span class="math inline">\(\alpha, \sigma_1, \sigma_2\)</span>, which can be made quickly and accurately without regard for the dimensionality of the problem (e.g.&nbsp;using MLE).</p>
<p>I tested this estimator via simulation on a range of different true correlation values, assuming other parameters <span class="math inline">\(\alpha, \gamma_1, \gamma_2\)</span> are known. I ran this on a Databricks cluster running an i3.4xlarge node with 16 cores. This simulation took approximately 3 days to run.</p>
<p><img src="images/sce_convergence.png" class="img-fluid"></p>
<p>The plot above shows the convergence of the estimated correlation to the true correlation (red horizontal line). Each linetype represents a different choice of p.&nbsp;A couple things are clear from the results of the simulation: the estimator does show good convergence to the true correlation value, but not for all values of p, not consistently across all true correlation values, and not likely better than MLE (MLE simulations were done separately, but haven’t been incoporated into these plots).</p>
<p><img src="images/sce_var.png" class="img-fluid"></p>
<p>This estimator is interesting, and may be useful for some cases where other parameters are known, or if speed is more important than accuracy. Most importantly, it actually performs quite well in regimes of interest for real-world equity returns (between 0.2 and 0.8) However the fact that it must be constructed elementwise is a strike against it compared to other options, as is the fact that it still requires estimates of <span class="math inline">\(\alpha\)</span> and each marginal distribution’s scale. Also, the wrong choice of p takes this from a possibly competitive estimator to a terrible one, which may be a problem in practice when true parameter values are unknown.</p>
<p><img src="images/sce_p_variance.png" class="img-fluid"></p>
<p>One important desirable property is that there does seem to be an optimal p in the sense of variance mimization across the range of <span class="math inline">\(\alpha\)</span> values. This suggests that the problem of choosing p may not be as big as it seems. For p=0.4, for instance, variance is guaranteed to be finite for all relevant cases (since we assume <span class="math inline">\(\alpha&gt;1\)</span> already), and estimator performance should be reasonably good.</p>
<p>Still do to: - Incorporate MLE estimates for comparison - Test if there is a fixed best p when defined in terms of <span class="math inline">\(\alpha\)</span>.</p>
</section>
<section id="restricted-expectation-maximization-approach" class="level2">
<h2 class="anchored" data-anchor-id="restricted-expectation-maximization-approach">Restricted Expectation-Maximization Approach</h2>
<p>My original research proposal suggested estimating and then conditioning on the stable subordinator in the <span class="math inline">\(\alpha\)</span>-SG(<span class="math inline">\(\Sigma\)</span>) random variable. A natural approach to this is expectation-maximization, but I was resistant to this at first because if the MLE is accessible then it seems like we should obviously prefer it to EM, which only <em>hopes</em> to converge to the MLE. And since Median Oracle appears to do better than the MLE in the high-dimensional setting, there’s no point to this approach. But on deeper consideration, this may yield better estimates than EM in the high-dimensional setting.</p>
<p>If we estimate and then condition on the realized latent variable W (the maximally skewed stable random variable), we can get <span class="math inline">\(X|W=w \sim N(0,w\Sigma)\)</span>. Moreover since the estimation of each <span class="math inline">\(w_i\)</span> happens in the cross-section, I’d expect the estimation error of these variables to decrease as the dimensionality increases, whereas the error of <span class="math inline">\(\Sigma_{EM}\)</span> will of course increase - while estimating <span class="math inline">\(w_i^{(t)}\)</span> relies on the estimate <span class="math inline">\(\Sigma^{(t-1)}\)</span>, it may be less impacted by a “bad” estimate, especially if we ultimately only care about correlations (consider the single-observation case). Taking the <span class="math inline">\(X|W\)</span> and plugging this into the closed form MLE for <span class="math inline">\(\Sigma\)</span> given Gaussian data should give us a better estimate. Better still, adjusting this MLE for high dimensionality using the RIE should yield an even better estimate.</p>
<p>Likewise, this should be provable using asymptotic efficiency of MLE.</p>
<p>EM for stable random vectors isn’t straightforward, and an approach was only first offered in 2018 by <a href="https://www.atlantis-press.com/journals/jsta/25903298">Teimouri et. al.&nbsp;</a>. This approach requires a conditional maximization (CM) step, then a conditional maximization of the likelihood (CML) step, which itself involves a separate stochastic EM to approximate the parameters of a related Weibull distribution. This is required because the authors are trying to jointly estimate all parameters via EM. Since we’re only interested in <span class="math inline">\(\Sigma\)</span>, we can actually simplify <span class="math inline">\(\alpha\)</span>-SG(<span class="math inline">\(\Sigma\)</span>) EM significantly, both computationally and conceptually, by restricting our parameter search to not include <span class="math inline">\(\alpha\)</span>, totally eliminating the CML step, and making the process equivalent to a simple Gaussian EM with a conditional maximization step for W.</p>
<p><a href="./EM_approach.html">My approach to stable EM is detailed here.</a></p>
</section>
<section id="normalized-sample-covariance-matrix-approach-nscm" class="level2">
<h2 class="anchored" data-anchor-id="normalized-sample-covariance-matrix-approach-nscm">Normalized Sample Covariance Matrix Approach (NSCM)</h2>
<p>The idea was to estimate the correlation matrix with NSCM (by inverting its expected eigenvalues), and then rescaling via EM. Need to add more details on the procedure, since it’s pretty cool.</p>
</section>
<section id="empricical-copula-transform" class="level2">
<h2 class="anchored" data-anchor-id="empricical-copula-transform">Empricical Copula Transform</h2>
<p>Since univariate stable MLE works well (fast and very accurate), one idea I had is to recreate the full dispersion matrix via lower-dimensional sub-matrices. These can be used to estimate W (as in EM above). Taking this idea to the limit (e.g.&nbsp;the marginals) yields this new idea…</p>
<p>In testing, this new approach works incredibly well, besting direct MLE calculations both in terms of error and time (by a lot).</p>
<p>Results and detailed procedures here here: <a href="./copula_transform.html">Linked Copula Transform Estimator</a>.</p>
<p>[Last Updated on November 30, 2024]</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>